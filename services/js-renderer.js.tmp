// services/js-renderer.js
// JavaScript renderer with Browserless.io integration for Cloud deployment

const { logger } = require('../utils/logger');
const fetch = require('node-fetch');

// Import Playwright conditionally
let chromium = null;
try {
    const playwright = require('playwright-core');
    chromium = playwright.chromium;
} catch (error) {
    logger.warn('Playwright not available, Browserless.io will be used for JS rendering');
}

class JavaScriptRenderer {
    constructor() {
        // Security: Build endpoint from separate env vars, never expose token to client
        this.browserlessToken = process.env.BROWSERLESS_TOKEN || null;
        this.browserlessBaseUrl = process.env.BROWSERLESS_URL || 'https://production-sfo.browserless.io'; // Updated to new endpoint
        this.useBrowserless = !!this.browserlessToken; // Use Browserless if we have a token
        
        // Local Playwright fallback (disabled by default in production)
        this.browser = null;
        this.isInitialized = false;
        this.enableLocalPlaywright = process.env.ENABLE_LOCAL_PLAYWRIGHT === '1';
        
        // Tuned timeouts for production stability
        this.maxPageAge = 30000; // 30 seconds max page lifetime
        this.requestTimeout = 60000; // 60 second timeout for complex pages
        this.maxRetries = 3; // Retry failed requests
        
        // Rate limiting and circuit breaker
        this.requestCount = 0;
        this.errorCount = 0;
        this.circuitOpen = false;
        this.lastErrorTime = 0;
        
        if (this.useBrowserless) {
            logger.info('Using Browserless.io for JavaScript rendering (production mode)');
        } else if (this.enableLocalPlaywright) {
            logger.info('Using local Playwright for JavaScript rendering (development mode)');
        } else {
            logger.info('JavaScript rendering disabled (no Browserless token and local Playwright disabled)');
        }
    }

    async initialize() {
        if (this.isInitialized && this.browser) {
            return;
        }

        try {
            logger.info('Initializing lightweight headless browser...');
            
            if (!chromium) {
                throw new Error('Playwright chromium not available');
            }
            
            // Launch Chromium with optimized flags for serverless/lightweight usage
            this.browser = await chromium.launch({
                headless: true,
                args: [
                    '--headless=new',
                    '--disable-dev-shm-usage',
                    '--disable-background-timer-throttling',
                    '--disable-renderer-backgrounding',
                    '--no-sandbox',
                    '--no-zygote',
                    '--single-process',
                    '--js-flags=--lazy',
                    '--blink-settings=imagesEnabled=false',
                    '--disable-extensions',
                    '--disable-plugins',
                    '--disable-background-networking',
                    '--disable-background-timer-throttling',
                    '--disable-client-side-phishing-detection',
                    '--disable-default-apps',
                    '--disable-hang-monitor',
                    '--disable-popup-blocking',
                    '--disable-prompt-on-repost',
                    '--disable-sync',
                    '--disable-translate',
                    '--disable-ipc-flooding-protection',
                    '--memory-pressure-off',
                    '--max_old_space_size=256'
                ]
            });

            this.isInitialized = true;
            logger.info('Headless browser initialized successfully');
        } catch (error) {
            logger.error('Failed to initialize headless browser:', error);
            throw error;
        }
    }

    async renderPage(url, options = {}) {
        // Circuit breaker: if too many errors recently, fail fast
        if (this.circuitOpen) {
            const timeSinceLastError = Date.now() - this.lastErrorTime;
            if (timeSinceLastError < 60000) { // 1 minute circuit breaker
                throw new Error('Circuit breaker open: too many recent errors');
            } else {
                this.circuitOpen = false; // Reset circuit breaker
                this.errorCount = 0;
            }
        }

        // Rate limiting check
        this.requestCount++;
        logger.info(`JS rendering request #${this.requestCount} for ${url}`);

        if (this.useBrowserless) {
            return this.renderPageWithBrowserlessRetry(url, options);
        } else if (this.enableLocalPlaywright) {
            return this.renderPageWithPlaywright(url, options);
        } else {
            throw new Error('JavaScript rendering not enabled');
        }
    }

    async renderPageWithBrowserlessRetry(url, options = {}) {
        let lastError;
        
        for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
            try {
                // Exponential backoff with jitter
                if (attempt > 1) {
                    const baseDelay = Math.pow(2, attempt - 1) * 100; // 100ms, 200ms, 400ms
                    const jitter = Math.random() * 100;
                    const delay = baseDelay + jitter;
                    logger.info(`Retry attempt ${attempt} after ${Math.round(delay)}ms`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }

                const result = await this.renderPageWithBrowserless(url, options);
                
                // Success: reset error tracking
                if (this.errorCount > 0) {
                    this.errorCount = 0;
                    logger.info('Error count reset after successful request');
                }
                
                return result;

            } catch (error) {
                lastError = error;
                this.errorCount++;
                this.lastErrorTime = Date.now();
                
                logger.warn(`Browserless attempt ${attempt} failed:`, error.message);
                
                // Open circuit breaker if too many errors
                if (this.errorCount >= 5) {
                    this.circuitOpen = true;
                    logger.error('Circuit breaker opened: too many consecutive errors');
                }

                // Don't retry on certain errors (rate limiting, auth errors)
                if (error.message.includes('429') || error.message.includes('401') || error.message.includes('403')) {
                    logger.error('Non-retryable error, failing immediately:', error.message);
                    break;
                }
            }
        }

        throw lastError || new Error('All retry attempts failed');
    }

    async renderPageWithBrowserless(url, options = {}) {
        const analysisType = options.includePerformance ? 'lighthouse' : 'content';
        
        try {
            logger.info(`Running ${analysisType} analysis for: ${url} (via Browserless.io)`);
            
            if (options.includePerformance) {
                return this.runLighthouseAnalysis(url, options);
            } else {
                return this.runContentAnalysis(url, options);
            }
        } catch (error) {
            logger.error(`Browserless.io ${analysisType} analysis failed for ${url}:`, error);
            throw error;
        }
    }

    async runContentAnalysis(url, options = {}) {
        // Minimal v2-compliant Browserless function - simplified for debugging
        const browserlessScript = `
            export default async ({ page }) => {
                try {
                    // Basic page setup
                    await page.setViewportSize({ width: 1200, height: 800 });
                    
                    // Simple navigation - no route filtering initially
                    console.log('Navigating to: ${url}');
                    const response = await page.goto("${url}", {
                        waitUntil: 'domcontentloaded',
                        timeout: 15000
                    });
                    
                    console.log('Navigation response:', response.status());
                    
                    // Wait for content to load
                    await page.waitForTimeout(3000);

                // Analyze JavaScript usage
                const jsAnalysis = await page.evaluate(() => {
                    const frameworks = {
                        react: !!(window.React || document.querySelector('[data-reactroot]')),
                        vue: !!(window.Vue || document.querySelector('[data-server-rendered="true"]')),
                        angular: !!(window.angular || document.querySelector('[ng-app]')),
                        jquery: !!(window.jQuery || window.$),
                        nextjs: !!(window.__NEXT_DATA__),
                        spa: document.querySelector('div[id="app"], div[id="root"]') !== null
                    };

                    const scripts = document.querySelectorAll('script');
                    const scriptCount = {
                        inline: Array.from(scripts).filter(s => !s.src).length,
                        external: Array.from(scripts).filter(s => s.src).length,
                        total: scripts.length
                    };

                    return {
                        frameworks,
                        scriptCount,
                        isJSHeavy: scriptCount.external > 10 || Object.values(frameworks).some(Boolean)
                    };
                });

                // Get metrics
                const metrics = await page.evaluate(() => ({
                    dom: {
                        elementCount: document.querySelectorAll('*').length,
                        scriptTags: document.querySelectorAll('script').length
                    }
                }));

                    return {
                        html: await page.content(),
                        jsMetrics: jsAnalysis,
                        metrics,
                        status: response?.status() || 200,
                        url: page.url(),
                        analysisType: 'content'
                    };
                    
                } catch (error) {
                    console.error('Browserless function error:', error);
                    return {
                        error: error.message,
                        html: '',
                        jsMetrics: null,
                        status: 500,
                        analysisType: 'content'
                    };
                }
            }
        `;

        return this.executeBrowserlessScript(browserlessScript);
    }

    async runLighthouseAnalysis(url, options = {}) {
        logger.info(`Running Lighthouse performance audit for: ${url}`);
        
        // Use Browserless Lighthouse endpoint with query parameter authentication  
        const lighthouseEndpoint = `${this.browserlessBaseUrl}/performance?token=${this.browserlessToken}
        const headers = {
            'Content-Type': 'application/json',
        };

        // Simplified Lighthouse config for Browserless.io v2
        const lighthouseConfig = {
            url: url
        };

        const abortController = new AbortController();
        const timeoutId = setTimeout(() => abortController.abort(), this.requestTimeout);

        try {
            const response = await fetch(lighthouseEndpoint, {
                method: 'POST',
                headers,
                body: JSON.stringify(lighthouseConfig),
                signal: abortController.signal
            });

            clearTimeout(timeoutId);

            if (!response.ok) {
                throw new Error(`Lighthouse API error: ${response.status} ${response.statusText}`);
            }

            const lighthouseResult = await response.json();
            
            return {
                lighthouse: lighthouseResult,
                analysisType: 'lighthouse',
                url: url,
                status: 200
            };

        } catch (error) {
            clearTimeout(timeoutId);
            throw error;
        }
    }

    async executeBrowserlessScript(script) {
        try {
            const browserlessScript = script;

            // Use query parameter authentication (Browserless.io requirement)
            const browserlessEndpoint = `${this.browserlessBaseUrl}/function?token=${this.browserlessToken}}}}`;
            const headers = {
                'Content-Type': 'application/json',
            };

            // Browserless V2 API expects just the code string directly
            const requestBody = {
                code: browserlessScript
            };

            // Create AbortController for timeout handling
            const abortController = new AbortController();
            const timeoutId = setTimeout(() => abortController.abort(), this.requestTimeout);

            const response = await fetch(browserlessEndpoint, {
                method: 'POST',
                headers,
                body: JSON.stringify(requestBody),
                signal: abortController.signal
            });

            clearTimeout(timeoutId);

            if (!response.ok) {
                // Log response body for debugging v2 API issues
                const errorBody = await response.text();
                console.error(`Browserless v2 API Error Response:`, {
                    status: response.status,
                    statusText: response.statusText,
                    body: errorBody,
                    endpoint: browserlessEndpoint
                });
                throw new Error(`Browserless API error: ${response.status} ${response.statusText} - ${errorBody.substring(0, 200)}`);
            }

            const result = await response.json();
            logger.info('Browserless.io rendering completed successfully');
            return result;
        } catch (error) {
            logger.error('Browserless.io rendering failed:', error);
            throw error;
        }
    }

    async renderPageWithPlaywright(url, options = {}) {
        await this.initialize();
        
        const page = await this.browser.newPage({
            viewport: { width: 1200, height: 800 }, // Small viewport
            userAgent: 'Mozilla/5.0 (compatible; SEO-Audit-Bot/1.0; +https://seo-audit.example.com/bot)'
        });

        try {
            // Set up request interception for resource blocking
            await page.route('**/*', (route) => {
                const resourceType = route.request().resourceType();
                const url = route.request().url();
                
                // Block resource-heavy content types
                if (['image', 'font', 'media', 'stylesheet'].includes(resourceType)) {
                    return route.abort();
                }
                
                // Block tracking and analytics
                if (this.isTrackingUrl(url)) {
                    return route.abort();
                }
                
                // Allow only document, xhr, fetch for first-party and essential CDNs
                if (['document', 'xhr', 'fetch', 'script'].includes(resourceType)) {
                    return route.continue();
                }
                
                route.abort();
            });

            // Set timeouts
            page.setDefaultTimeout(this.requestTimeout);
            page.setDefaultNavigationTimeout(this.requestTimeout);

            // Navigate to page
            logger.info(`Rendering JavaScript content for: ${url}`);
            const response = await page.goto(url, {
                waitUntil: 'domcontentloaded',
                timeout: this.requestTimeout
            });

            // Wait for potential dynamic content with short timeout
            await page.waitForTimeout(2000); // 2 second wait for JS execution

            // Try to detect if page uses significant JavaScript
            const jsMetrics = await this.analyzeJavaScriptUsage(page);

            // Get the rendered HTML
            const renderedHtml = await page.content();
            
            // Get page metrics
            const metrics = await this.getPageMetrics(page);

            return {
                html: renderedHtml,
                jsMetrics,
                metrics,
                status: response?.status() || 200,
                url: page.url()
            };

        } catch (error) {
            logger.error(`Failed to render page ${url}:`, error);
            throw error;
        } finally {
            await page.close().catch(() => {}); // Ensure cleanup
        }
    }

    async analyzeJavaScriptUsage(page) {
        try {
            const jsAnalysis = await page.evaluate(() => {
                // Detect common JS frameworks/libraries
                const frameworks = {
                    react: !!(window.React || document.querySelector('[data-reactroot]') || document.querySelector('[data-react-checksum]')),
                    vue: !!(window.Vue || document.querySelector('[data-server-rendered="true"]')),
                    angular: !!(window.angular || document.querySelector('[ng-app]') || document.querySelector('[ng-version]')),
                    jquery: !!(window.jQuery || window.$),
                    nextjs: !!(window.__NEXT_DATA__),
                    nuxt: !!(window.__NUXT__ || window.$nuxt),
                    spa: document.querySelector('div[id="app"], div[id="root"], div[id="__next"]') !== null
                };

                // Count script tags
                const scripts = document.querySelectorAll('script');
                const inlineScripts = Array.from(scripts).filter(s => !s.src).length;
                const externalScripts = Array.from(scripts).filter(s => s.src).length;

                // Check for dynamic content indicators
                const dynamicIndicators = {
                    hasLoadingSpinners: document.querySelector('.loading, .spinner, [class*="load"]') !== null,
                    hasSkeletonScreens: document.querySelector('.skeleton, [class*="skeleton"]') !== null,
                    hasLazyLoading: document.querySelector('[data-lazy], [loading="lazy"]') !== null,
                    hasAsyncContent: document.querySelector('[data-async], [data-fetch]') !== null
                };

                // Measure content differences
                const staticContentRatio = document.querySelectorAll('[data-ssr], [data-server-rendered]').length / Math.max(document.querySelectorAll('*').length, 1);

                return {
                    frameworks,
                    scriptCount: {
                        inline: inlineScripts,
                        external: externalScripts,
                        total: scripts.length
                    },
                    dynamicIndicators,
                    staticContentRatio,
                    isJSHeavy: externalScripts > 10 || inlineScripts > 5 || Object.values(frameworks).some(Boolean)
                };
            });

            return jsAnalysis;
        } catch (error) {
            logger.warn('Failed to analyze JavaScript usage:', error);
            return { isJSHeavy: false, error: error.message };
        }
    }

    async getPageMetrics(page) {
        try {
            const metrics = await page.evaluate(() => ({
                dom: {
                    elementCount: document.querySelectorAll('*').length,
                    textNodes: document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT).nextNode() ? 1 : 0,
                    scriptTags: document.querySelectorAll('script').length
                },
                timing: performance.timing ? {
                    domContentLoaded: performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart,
                    loadComplete: performance.timing.loadEventEnd - performance.timing.navigationStart
                } : {}
            }));

            return metrics;
        } catch (error) {
            logger.warn('Failed to get page metrics:', error);
            return {};
        }
    }

    isTrackingUrl(url) {
        const trackingPatterns = [
            /google-analytics\.com/,
            /googletagmanager\.com/,
            /facebook\.net/,
            /doubleclick\.net/,
            /googlesyndication\.com/,
            /amazon-adsystem\.com/,
            /adsystem\.amazon/,
            /ads\.yahoo\.com/,
            /scorecardresearch\.com/,
            /quantserve\.com/,
            /outbrain\.com/,
            /taboola\.com/,
            /twitter\.com\/i\/adsct/,
            /analytics/,
            /tracking/,
            /telemetry/
        ];

        return trackingPatterns.some(pattern => pattern.test(url));
    }

    async close() {
        if (this.browser) {
            try {
                await this.browser.close();
                this.browser = null;
                this.isInitialized = false;
                logger.info('Headless browser closed');
            } catch (error) {
                logger.error('Error closing browser:', error);
            }
        }
    }

    // Health check for the renderer
    async healthCheck() {
        if (this.useBrowserless) {
            return this.healthCheckBrowserless();
        } else {
            return this.healthCheckPlaywright();
        }
    }

    async healthCheckBrowserless() {
        const healthInfo = {
            mode: 'browserless',
            endpoint: this.browserlessBaseUrl,
            hasToken: !!this.browserlessToken,
            tokenLength: this.browserlessToken ? this.browserlessToken.length : 0
        };

        try {
            // Simple probe to validate Browserless connection
            logger.info('Probing Browserless.io connection...');
            const probe = `export default async ({ page }) => { 
                await page.goto('data:text/html,<h1>Health Check</h1>');
                return { 
                    ok: true, 
                    timestamp: new Date().toISOString(),
                    userAgent: await page.evaluate(() => navigator.userAgent)
                }; 
            }`;
            
            const result = await this.executeBrowserlessScript(probe);
            
            return {
                ...healthInfo,
                status: 'healthy',
                probeResult: result,
                lastChecked: new Date().toISOString()
            };
        } catch (error) {
            logger.error('Browserless health check failed:', error);
            
            // Parse different error types
            let errorType = 'unknown';
            let errorDetails = error.message;
            
            if (error.message.includes('401')) {
                errorType = 'authentication';
                errorDetails = 'Invalid or expired Browserless token';
            } else if (error.message.includes('403')) {
                errorType = 'authorization';
                errorDetails = 'Token valid but insufficient permissions';
            } else if (error.message.includes('429')) {
                errorType = 'rate_limit';
                errorDetails = 'Rate limit exceeded - too many requests';
            } else if (error.message.includes('timeout') || error.message.includes('ECONNRESET')) {
                errorType = 'timeout';
                errorDetails = 'Connection timeout to Browserless service';
            } else if (error.message.includes('ENOTFOUND') || error.message.includes('ECONNREFUSED')) {
                errorType = 'network';
                errorDetails = 'Cannot reach Browserless service';
            }
            
            return {
                ...healthInfo,
                status: 'degraded',
                error: {
                    type: errorType,
                    message: errorDetails,
                    rawError: error.message,
                    stack: error.stack?.split('\n').slice(0, 3).join('\n')
                },
                lastChecked: new Date().toISOString(),
                troubleshooting: {
                    checkToken: errorType === 'authentication',
                    checkPlan: errorType === 'authorization' || errorType === 'rate_limit',
                    checkNetwork: errorType === 'network' || errorType === 'timeout'
                }
            };
        }
    }

    async healthCheckPlaywright() {
        try {
            await this.initialize();
            return {
                status: 'healthy',
                mode: 'playwright',
                browserConnected: !!this.browser?.isConnected(),
                initialized: this.isInitialized
            };
        } catch (error) {
            return {
                status: 'unhealthy',
                mode: 'playwright',
                error: error.message,
                initialized: false
            };
        }
    }
}

module.exports = JavaScriptRenderer;